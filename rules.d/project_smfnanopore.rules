"""
Dependecies: Need to install 
"""

default_smalljob_params = {"runtime":'1:00', "memusage":'4000', "slots":'1', "misc":''}
default_sortjob_params = {"runtime":'8:00', "memusage":'32000', "slots":'16', "misc":''}

rule accessibility_to_timp_format:
    input: rules.predict_accessibility.output.prediction
    output: temp(Path(basedir).joinpath('calls_timp_format', "tmp", "np_accessibility_{sample}_batch_{batch}_flank_{minflank}_thres_{llr_thres}.tsv"))
    params:
        **default_smalljob_params,
        jobname = "convert_timp_format_{sample}_{batch}_{minflank}"
    run:
        from nanopolish_smf.timp_format import Converter
        from nanopolish_smf.accessibility import AccessibilityEntry
        with Converter(reference, llr_threshold=float(wildcards["llr_thres"]), flank=2) as conv:
            conv.convert_file(str(input), str(output))

def merge_accessibility_timp_format_input(wildcards):
    for sample, batch in zip(sbf.sb_samples, sbf.sb_batches):
        yield rules.accessibility_to_timp_format.output[0].format(sample=sample, batch=batch, minflank=wildcards["minflank"], llr_thres=wildcards["llr_thres"])

rule merge_accessibility_timp_format:
    input: merge_accessibility_timp_format_input
    output: Path(basedir).joinpath('calls_timp_format', "np_accessibility_flank_{minflank}_thres_{llr_thres}.tsv.bgz")
    params:
        **default_sortjob_params,
        jobname = "merge_timp_format_{minflank}"
    shell: """
               {tabix_load_hook}
               cat {input} | sort --parallel={params.slots} -T {scratch_dir} -k1,1 -k2,2n | bgzip > {output};
               sleep 10 # napping to make sure index is not too new
               tabix -p bed  {output}
            """

rule all_merge_accessibility_timp_format:
    input: expand(rules.merge_accessibility_timp_format.output, minflank=all_flanking_options, llr_thres=llr_threshold_accessibility)

rule nanopolish_to_timp_format:
    input: rules.metcall.output
    output: temp(Path(basedir).joinpath('calls_timp_format', "tmp", "np_metcalls_{sample}_batch_{batch}_mtype_{mtype}_thres_{llr_thres}.tsv"))
    params:
        **default_smalljob_params,
        jobname = "convert_timp_format_{sample}_{batch}_{mtype}"
    shell:
        "{python} {nanopolish_timp_conversion_script} -c {wildcards.llr_thres} -i {input} -q {wildcards.mtype} -g {reference} > {output}"

def merge_metcall_timp_format_input(wildcards):
    for sample, batch in zip(sbf.sb_samples, sbf.sb_batches):
        yield rules.nanopolish_to_timp_format.output[0].format(sample=sample, batch=batch, mtype=wildcards["mtype"], llr_thres=wildcards["llr_thres"])

rule merge_metcall_timp_format:
    input: merge_metcall_timp_format_input
    output: Path(basedir).joinpath('calls_timp_format', "np_metcall_{mtype}_thres_{llr_thres}.tsv.bgz")
    params:
        **default_sortjob_params,
        jobname = "merge_timp_format_{mtype}"
    shell: """
               {tabix_load_hook}
               cat {input} | sort --parallel={params.slots} -T {scratch_dir} -k1,1 -k2,2n | bgzip > {output};
               sleep 10 # napping to make sure index is not too new
               tabix -p bed  {output}
            """

rule all_merge_metcall_timp_format:
    input: expand(rules.merge_metcall_timp_format.output, mtype=["cpg", "gpc"], llr_thres=llr_threshold_nanopolish)

rule nanonome_to_timp_format:
    input: rules.nanonome.output
    output: temp(Path(basedir).joinpath('calls_timp_format', "tmp", "nanonome_{sample}_batch_{batch}_thres_{llr_thres}.tsv"))
    params:
        **default_smalljob_params,
        jobname = "convert_timp_format_{sample}_{batch}"
    shell:
        "{python} {nanopolish_timp_conversion_script} -c {wildcards.llr_thres} -i {input} -q cpggpc -g {reference} > {output}"

def merge_nanonome_timp_format_input(wildcards):
    for sample, batch in zip(sbf.sb_samples, sbf.sb_batches):
        yield rules.nanonome_to_timp_format.output[0].format(sample=sample, batch=batch, llr_thres=wildcards["llr_thres"])

rule merge_nanonome_timp_format:
    input: merge_nanonome_timp_format_input
    output: Path(basedir).joinpath('calls_timp_format', "nanonome_thres_{llr_thres}.tsv.bgz")
    params:
        **default_sortjob_params,
        jobname = "merge_timp_format_nanonome"
    shell: """
               {tabix_load_hook}
               cat {input} | sort --parallel={params.slots} -T {scratch_dir} -k1,1 -k2,2n | bgzip > {output};
               sleep 10 # napping to make sure index is not too new
               tabix -p bed  {output}
            """

rule all_merge_nanonome_timp_format:
    input: expand(rules.merge_nanonome_timp_format.output, llr_thres=llr_threshold_nanonome)


rule bonito_timp_format:
    input: bam=rules.bonito_basecall_metcall.output.sorted,
           bai=rules.bonito_basecall_metcall.output.sorted + ".bai"
    output: Path(basedir).joinpath("calls_timp_format", "tmp", "bonito_metcalls_{sample}_batch_{batch}_mtype_thres_{llr_thres}.tsv")
    params:
        **default_smalljob_params,
        jobname="convert_bonito_timp_format_{sample}_{batch}"
    run:
        from modbampy import ModBam
        import numpy as np
        from nanopolish_smf.timp_format import Converter
        from nanopolish_smf.accessibility import AccessibilityEntry

        def p_to_llr(p, prior=0.5):
            """
            Converts the posterior probability p(a|x) into a log-likelihood ratio
            log(p(x|a)/p(x|~a)) given a prior pa(a)
            """
            return -np.log(prior * (1 - p) / (p * (1 - prior)))

        with Converter(reference, llr_threshold=float(wildcards["llr_thres"]), motifs={"CG"}) as converter, open(output[0], "wt") as out_f:
            for chrom in converter.ref.keys():
                for read in ModBam(input.bam,chrom,0,len(converter.ref[chrom])).reads():
                    llrs = np.zeros((read.reference_end - read.reference_start))
                    for pos_mod in read.mod_sites:
                        rpos = pos_mod.rpos
                        if rpos < 0:
                            continue
                        if read.is_reverse:
                            rpos -= 1  # otherwise it points at the G
                        p = float(pos_mod.qual) / 256
                        llrs[rpos - read.reference_start] = p_to_llr(np.clip(p, 0.000001, 0.999999))

                    read_entry = AccessibilityEntry(chrom,read.reference_start,read.reference_end,
                        True,read.query_name,llrs)

                    timp_line = converter.format_line(converter.convert_line(read_entry))
                    if timp_line is None:
                        continue
                    out_f.write(f"{timp_line}\n")


def merge_bonito_timp_format_input(wildcards):
    for sample, batch in zip(sbf.sb_samples, sbf.sb_batches):
        yield rules.bonito_timp_format.output[0].format(sample=sample, batch=batch, llr_thres=wildcards["llr_thres"])


rule merge_bonito_timp_format:
    input: merge_bonito_timp_format_input
    output: Path(basedir).joinpath('calls_timp_format', "bonito_thres_{llr_thres}.tsv.bgz")
    params:
        **default_sortjob_params,
        jobname = "merge_timp_format_bonito"
    shell: """
               {tabix_load_hook}
               cat {input} | sort --parallel={params.slots} -T {scratch_dir} -k1,1 -k2,2n | bgzip > {output};
               sleep 10 # napping to make sure index is not too new
               tabix -p bed  {output}
            """

rule all_merge_bonito_timp_format:
    input: expand(rules.merge_bonito_timp_format.output, llr_thres="2.0")



rule all_smf_timpformat:
    input:
        expand(rules.merge_nanonome_timp_format.output,llr_thres=llr_threshold_nanonome),
        expand(rules.merge_metcall_timp_format.output, mtype=["cpg", "gpc"], llr_thres=llr_threshold_nanopolish),
        expand(rules.merge_accessibility_timp_format.output, minflank=all_flanking_options, llr_thres=llr_threshold_accessibility),
        expand(rules.merge_bonito_timp_format.output, llr_thres=llr_threshold_accessibility),

rule all_smf_nanopore:
    input:
        expand(rules.mergebams.output, sample=unique_samples),
        expand(rules.pycoqc_report.output, sample=unique_samples),
        expand(rules.merge_nanonome_timp_format.output,llr_thres=llr_threshold_nanonome),
        expand(rules.merge_metcall_timp_format.output,mtype=["cpg", "gpc"],llr_thres=llr_threshold_nanopolish),
        expand(rules.merge_accessibility_timp_format.output,minflank=all_flanking_options,llr_thres=llr_threshold_accessibility),
        expand(rules.merge_bonito_timp_format.output, llr_thres=llr_threshold_accessibility),